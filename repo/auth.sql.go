// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const checkEmail = `-- name: CheckEmail :one
select exists (select 1 from credentials where email = $1 for update)
`

func (q *Queries) CheckEmail(ctx context.Context, email string) (bool, error) {
	row := q.queryRow(ctx, q.checkEmailStmt, checkEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteStaleEmailVerificationTokens = `-- name: DeleteStaleEmailVerificationTokens :exec
delete from email_verification_tokens where expires_at <= now()
`

func (q *Queries) DeleteStaleEmailVerificationTokens(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteStaleEmailVerificationTokensStmt, deleteStaleEmailVerificationTokens)
	return err
}

const getCredentialsByEmail = `-- name: GetCredentialsByEmail :one
select id, email, email_is_verified, password_hash, created_at from credentials where email = $1
`

func (q *Queries) GetCredentialsByEmail(ctx context.Context, email string) (Credential, error) {
	row := q.queryRow(ctx, q.getCredentialsByEmailStmt, getCredentialsByEmail, email)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailIsVerified,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getEmailVerificationTokenByID = `-- name: GetEmailVerificationTokenByID :one
select id, email, created_at, expires_at from email_verification_tokens where id = $1
`

func (q *Queries) GetEmailVerificationTokenByID(ctx context.Context, id uuid.UUID) (EmailVerificationToken, error) {
	row := q.queryRow(ctx, q.getEmailVerificationTokenByIDStmt, getEmailVerificationTokenByID, id)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
select id, credentials_id, token, csrf_token, created_at from sessions where id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.queryRow(ctx, q.getSessionByIDStmt, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.CredentialsID,
		&i.Token,
		&i.CsrfToken,
		&i.CreatedAt,
	)
	return i, err
}

const insertCredentials = `-- name: InsertCredentials :exec
insert into credentials (id, email, password_hash)
values ($1, $2, $3)
`

type InsertCredentialsParams struct {
	ID           uuid.UUID
	Email        string
	PasswordHash string
}

func (q *Queries) InsertCredentials(ctx context.Context, arg InsertCredentialsParams) error {
	_, err := q.exec(ctx, q.insertCredentialsStmt, insertCredentials, arg.ID, arg.Email, arg.PasswordHash)
	return err
}

const insertEmailVerificationToken = `-- name: InsertEmailVerificationToken :exec
insert into email_verification_tokens (id, email, expires_at)
values ($1, $2, $3)
`

type InsertEmailVerificationTokenParams struct {
	ID        uuid.UUID
	Email     string
	ExpiresAt time.Time
}

func (q *Queries) InsertEmailVerificationToken(ctx context.Context, arg InsertEmailVerificationTokenParams) error {
	_, err := q.exec(ctx, q.insertEmailVerificationTokenStmt, insertEmailVerificationToken, arg.ID, arg.Email, arg.ExpiresAt)
	return err
}

const insertSession = `-- name: InsertSession :one
insert into sessions (id, credentials_id, token, csrf_token)
values ($1, $2, $3, $4)
returning id, credentials_id, token, csrf_token, created_at
`

type InsertSessionParams struct {
	ID            uuid.UUID
	CredentialsID uuid.UUID
	Token         string
	CsrfToken     string
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.insertSessionStmt, insertSession,
		arg.ID,
		arg.CredentialsID,
		arg.Token,
		arg.CsrfToken,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.CredentialsID,
		&i.Token,
		&i.CsrfToken,
		&i.CreatedAt,
	)
	return i, err
}

const markEmailAsVerified = `-- name: MarkEmailAsVerified :exec
update credentials set email_is_verified = true where email = $1
`

func (q *Queries) MarkEmailAsVerified(ctx context.Context, email string) error {
	_, err := q.exec(ctx, q.markEmailAsVerifiedStmt, markEmailAsVerified, email)
	return err
}
